# An overview of my emulator's architecture (2025-08-05)

As those familiar with me know, I have taken it upon myself to write a [multisystem emulator](https://github.com/kay-lambdadelta/multiemu) named multiemu, largely with a heavy focus on modularity and accuracy without a large amount of complexity and effort on the end of the user.

Today, I wish to discuss some aspects of its design.

## Structural overview

```
multiemu-shell-* >> multiemu-frontend >> multiemu-runtime >> multiemu-definition-*
```

The software's architecture, at a high level and down to its lowest level, consists of "shells" (e.g., `multiemu-shell-destinezite` for desktop-like platforms) that provide basic runtime functionality for the `multiemu-frontend`, such as windowing/graphics glue, as well as audio functionality.

The frontend library provides the main loop and GUI driver code ([egui](https://docs.rs/egui/latest/egui/) at the moment) to provide the emulator’s core functionality. It also provides a base for the multiemu-runtime library to run on. This runtime library is arguably the most important part of the emulator as it supplies the interop between the largely unaware-of-platform definition crates and everything else (things such as the memory translation table and the machine itself).

The definition crates provide actual code needed for emulation, using mostly the utils provided in `multiemu-runtime` to accomplish this. They are written to be as unaware of the underlying platform as possible (except for graphics functionality, which understandably needs to be pretty tied to platform-specific APIs).


```
multiemu-* (/lib contents) >> multiemu-utils
```

The `multiemu-utils` utility is largely meant as a general-purpose command-line tool for managing the on-disk storage of this emulator, but right now most of its functionality concerns ROM organization and is actually quite useful for managing my personal collection of ROMs. 

## Closer view of select design choices

### "Home" folder

The home (at `$XDG_DATA_HOME/multiemu`) folder consists of several directories for data storage.

- `snapshots`/`saves`: storage for on-disk representations of persistent data. 

Snapshots are representations required to recreate the entire state of a device (commonly called a "save state"), while saves only consist of what data would persist given a power cut to the device. 

They are both stored in a "tree" like format, with nodes representing components as part of the machine, with a metadata file in [ron](https://docs.rs/ron/latest/ron/) (I will most likely change it to a non-textual format in the future).

- `ROMs`: internal ROM store

This emulator includes a ROM organizer, and I wished to take a bit of a novel approach with it.

I noticed a lot of emulators have a tendency to organize (if they choose to at all) snapshots and saves based upon the ROM file name, which always struck me as a way to lead to disorganization and confusion on the part of the user.

Instead, my emulator (using data from its internal database, usually populated from ROM information sites) chooses to store ROMs internally by their SHA1 sum (the best hash function I found for the most records on ROMs) and *symlink* them out to a folder at the user's request in a folder format more human-friendly

```
lambdadelta@ms-7c96:~/ROMs/Atari - Jaguar$ tree
├── Aircars (World) (Aftermarket) (Unl)
│   └── Aircars (World) (Aftermarket) (Unl).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/533c497761cc802624708108bc9ef6e7c4f40296
├── Alien vs Predator (World)
│   └── Alien vs Predator (World).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/fd8c89250ebc1e403838b2e589d1f69e3fe2fe02
├── Arena Football '95 (World) (Aftermarket) (Unl)
│   └── Arena Football '95 (World) (Aftermarket) (Unl).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/542063a5b27659781a85821f61e85cd89ea59ab3
├── Atari Karts (World)
│   └── Atari Karts (World).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/9c96e6c2195ce56aa930e677a041b35bd9b8bc7e
├── Attack of the Mutant Penguins (World)
│   └── Attack of the Mutant Penguins (World).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/01dc37e7a9d03246a93bcb8c6a3116cb6391ed31
├── Barkley Shut Up and Jam (World) (Aftermarket) (Unl)
│   └── Barkley Shut Up and Jam (World) (Aftermarket) (Unl).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/18535f5985c840aefce0fa639131cb83a8a647f9
├── Battle Sphere Gold (World) (Aftermarket) (Unl)
│   └── Battle Sphere Gold (World) (Aftermarket) (Unl).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/49716a6a3a4c6abeea36040f26c4e8cf2a545df7
├── Battle Sphere (World) (Aftermarket) (Unl)
│   └── Battle Sphere (World) (Aftermarket) (Unl).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/8f4c964d2411a52c64eec1d1a3061f77117bb7a6
├── [BIOS] Atari Jaguar CD (World)
│   └── [BIOS] Atari Jaguar CD (World).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/73883e7a6e9b132452436f7ab1aeaeb0776428e5
├── [BIOS] Atari Jaguar Developer CD (World)
│   └── [BIOS] Atari Jaguar Developer CD (World).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/d61b7b5912118f114ef00cf44966a5ef62e455a5
├── [BIOS] Atari Jaguar Stubulator '93 (World)
│   └── [BIOS] Atari Jaguar Stubulator '93 (World).j64 -> /home/lambdadelta/.local/share/multiemu/ROMs/8377ff6c6527721e2e7f8458314d782925ce4590
```

The emulator then uses the SHA1 to identify ROMs (along with, if relevant, the name of the game as marked in the database). This removes ambiguities on what a ROM is, how it should be addressed, and if the user cannot think of a scheme themselves, where it should be organized and stored. The code for it is roughly stored in `mulitemu-rom` and is shared between `multiemu-utils` and the crates concerned with playing games. Currently, it's meant to consume No-Intro type definition files in its database, but has basic redump support, and I *could* include other similar projects if the time comes.

### Decision for an egui-based GUI system

This is one of my least favorite parts of my work, but I decided it would be a great choice because egui is fairly fast, embeddable, has minimal control inversion, and most importantly, is simple enough I was able to teach myself vulkan and graphics programming in a week to write a proper rasterizer for it in software and vulkan. I suppose when I improve in the domain of user interface, I can give my emulator a bit less of a regrettable face.

Overall, these are the parts of the emulator I felt the most pressing need to explain.